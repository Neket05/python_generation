# Python Bootcamp

## Неделя 1


## Неделя 2 - Test Driven Development

TL; DR

Идея очень простая: прежде, чем писать код, нужно подумать, как этот кусок кода будет работать, подумать о случаях, когда он будет ломаться, и написать тест, который будет покрывать, как успешныеЮ, так и ломающие код кейсы. Тесты, которые покрывают атомарные куски кода называются unit tests, так как отвечают за тестирование каждого "юнита" (куска) кода. Обычно юнит тесты разрабатывают для функций, классов или отдельных методов. Есть и другие виды тестов, но в данном контексте нам интересны именно юнит тесты. 


## Пример юнит теста

Условно можно представить себе сценарий, в котором у нас есть модуль, содержащий ряд вспомогательных функций, одна из которых, например, add(x, y), которая возвращает сумму ее аргументов. Тогда можно представить себе отдельный скрипт, в который мы импортируем эту функцию и проверяем, действительно ли она возвращает ожидаемое значение.

```python
import add

# assert поднимает AssertionError если выражение после него возвращает False
def test_add_positive():
    assert add(2, 2) == 4

def test_add_negative():
    assert add(-2, -2) == -4

```
Обычно ситуации более сложные и приходится покрывать больше случаев, в которых код можно сломаться. Для этого пишется один assert на одни тест. То есть проверям в одном тесте только один сценарий или свойство.

## Прикладное значение

Главное правило: сначал тест, потом разрабатываем код, который этот тест пройдет. Нельзя разрабатывать больше кода, чем покрывает тест. И наоборот, тест должен тестировать только кусок кода, который необходим для решения прикладной задачи. То есть если мы хотим исправить баг, мы пишем тест, которые покрывает этот баг и потом разрабатываем фикс. Как правило, критерий хорошего пул реквеста -- это наличие в нем теста. Иначе, возникают вопросы, а работает ли вообще код, которые сейчас будет добавлен в основную ветку.